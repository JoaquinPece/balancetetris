<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Balance - Contabilidad Interactiva</title>
    
    <meta name="description" content="Juego tipo Tetris para aprender contabilidad. Clasifica elementos del balance mientras caen.">
    <meta name="keywords" content="tetris, contabilidad, balance, juego educativo">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Estilos personalizados -->
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <div id="root"></div>
    
    <!-- React Libraries -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Nuestros archivos JS -->
    <script src="js/config.js"></script>
    <script src="js/sounds.js"></script>
    <script src="js/game-logic.js"></script>
    <script type="text/babel" src="js/components.js"></script>
</body>
</html>
/* ESTILOS PRINCIPALES DEL TETRIS BALANCE */

/* Fondo principal del juego */
.game-container {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
}

/* Elemento cayendo - m√°s visible */
.falling-element {
    animation: fall 0.4s ease-out;
    cursor: grab;
    user-select: none;
    min-width: 140px;
    min-height: 90px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    border: 2px solid rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(4px);
}

.falling-element:active {
    cursor: grabbing;
    transform: scale(1.05) !important;
}

@keyframes fall {
    from { 
        transform: translateY(-40px) translateX(-50%) scale(0.7); 
        opacity: 0; 
    }
    to { 
        transform: translateY(0px) translateX(-50%) scale(1); 
        opacity: 1; 
    }
}

/* Efectos de brillo */
.glow {
    box-shadow: 0 0 40px rgba(255, 255, 255, 0.5);
}

.glow-strong {
    box-shadow: 0 0 60px rgba(255, 255, 255, 0.7);
}

/* Animaciones */
.shake {
    animation: shake 0.6s;
}

@keyframes shake {
    0%, 100% { transform: translateX(0); }
    10%, 30%, 50%, 70%, 90% { transform: translateX(-8px); }
    20%, 40%, 60%, 80% { transform: translateX(8px); }
}

.pulse {
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.8; transform: scale(1.02); }
}

/* √Årea de juego mejorada */
.game-board {
    background: rgba(0, 0, 0, 0.15);
    backdrop-filter: blur(15px);
    border-radius: 25px;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.drop-zone {
    background: rgba(255, 255, 255, 0.08);
    border: 3px dashed rgba(255, 255, 255, 0.4);
    border-radius: 20px;
    min-height: 280px;
    position: relative;
    overflow: hidden;
}

.drop-zone::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(
        45deg,
        rgba(255, 255, 255, 0.02) 25%,
        transparent 25%,
        transparent 75%,
        rgba(255, 255, 255, 0.02) 75%
    );
    background-size: 30px 30px;
    pointer-events: none;
}

/* Slots de categor√≠as mejorados */
.category-slot {
    min-height: 130px;
    border: 4px dashed transparent;
    transition: all 0.4s ease;
    cursor: pointer;
    position: relative;
    overflow: hidden;
}

.category-slot::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.1) 50%, transparent 70%);
    transform: translateX(-100%);
    transition: transform 0.6s;
}

.category-slot:hover::before {
    transform: translateX(100%);
}

.category-slot:hover {
    transform: scale(1.03);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
}

.category-slot.active {
    border-color: #fbbf24;
    background-color: rgba(251, 191, 36, 0.25);
    transform: scale(1.06);
    box-shadow: 0 0 30px rgba(251, 191, 36, 0.4);
}

.category-slot.correct {
    border-color: #10b981;
    background-color: rgba(16, 185, 129, 0.3);
    animation: correctPulse 1s;
}

.category-slot.incorrect {
    border-color: #ef4444;
    background-color: rgba(239, 68, 68, 0.3);
    animation: shake 0.6s;
}

@keyframes correctPulse {
    0%, 100% { transform: scale(1); }
    25% { transform: scale(1.08); }
    50% { transform: scale(1.12); }
    75% { transform: scale(1.08); }
}

/* Barra de progreso mejorada */
.progress-bar {
    height: 6px;
    border-radius: 10px;
    overflow: hidden;
    background: rgba(0, 0, 0, 0.3);
    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #10b981 0%, #fbbf24 50%, #ef4444 100%);
    border-radius: 10px;
    transition: width 0.1s ease-out;
    box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
}

/* Paneles con cristal */
.glass-panel {
    background: rgba(0, 0, 0, 0.25);
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 20px;
}

/* Botones mejorados */
.btn-primary {
    background: linear-gradient(135deg, #10b981 0%, #059669 100%);
    box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
    transition: all 0.3s ease;
}

.btn-primary:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
}

.btn-secondary {
    background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
    box-shadow: 0 4px 15px rgba(245, 158, 11, 0.3);
    transition: all 0.3s ease;
}

.btn-secondary:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(245, 158, 11, 0.4);
}

/* Feedback mejorado */
.feedback-correct {
    background: linear-gradient(135deg, rgba(16, 185, 129, 0.9) 0%, rgba(5, 150, 105, 0.9) 100%);
    border: 2px solid #10b981;
    box-shadow: 0 8px 32px rgba(16, 185, 129, 0.3);
    animation: feedbackSlideIn 0.5s ease-out;
}

.feedback-incorrect {
    background: linear-gradient(135deg, rgba(239, 68, 68, 0.9) 0%, rgba(220, 38, 38, 0.9) 100%);
    border: 2px solid #ef4444;
    box-shadow: 0 8px 32px rgba(239, 68, 68, 0.3);
    animation: feedbackSlideIn 0.5s ease-out;
}

@keyframes feedbackSlideIn {
    from {
        transform: translateY(-30px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

/* Estad√≠sticas en tiempo real */
.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 1rem;
}

.stat-item {
    text-align: center;
    padding: 1rem;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 15px;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

/* Responsive mejoras */
@media (max-width: 768px) {
    .falling-element {
        min-width: 120px;
        min-height: 80px;
    }
    
    .drop-zone {
        min-height: 240px;
    }
    
    .category-slot {
        min-height: 110px;
    }
    
    .game-container {
        padding: 1rem;
    }
}

@media (max-width: 480px) {
    .falling-element {
        min-width: 100px;
        min-height: 70px;
    }
    
    .drop-zone {
        min-height: 200px;
    }
    
    .category-slot {
        min-height: 100px;
    }
}

/* Efectos especiales para rachas */
.streak-effect {
    animation: streakGlow 1s infinite alternate;
}

@keyframes streakGlow {
    from {
        text-shadow: 0 0 10px #fbbf24;
    }
    to {
        text-shadow: 0 0 20px #fbbf24, 0 0 30px #f59e0b;
    }
}

/* Transiciones suaves */
* {
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

/* Mejoras de accesibilidad */
.sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
}
// SISTEMA DE AUDIO DEL TETRIS BALANCE

// CONFIGURACI√ìN DE AUDIO (por defecto apagado)
const AUDIO_CONFIG = {
    musicEnabled: false,        // M√∫sica apagada por defecto
    soundEffectsEnabled: true,  // Efectos de sonido activados por defecto
    masterVolume: 0.7,          // Volumen maestro (70%)
    musicVolume: 0.4,           // Volumen de m√∫sica (40%)
    effectsVolume: 0.6          // Volumen de efectos (60%)
};

// CLASE PARA MANEJAR EL AUDIO
class AudioManager {
    constructor() {
        this.audioContext = null;
        this.musicTimeout = null;
        this.isInitialized = false;
        
        // Estados de audio
        this.musicEnabled = AUDIO_CONFIG.musicEnabled;
        this.soundEffectsEnabled = AUDIO_CONFIG.soundEffectsEnabled;
        this.masterVolume = AUDIO_CONFIG.masterVolume;
        this.musicVolume = AUDIO_CONFIG.musicVolume;
        this.effectsVolume = AUDIO_CONFIG.effectsVolume;
    }

    // Inicializar contexto de audio
    init() {
        if (this.isInitialized) return;
        
        try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.isInitialized = true;
            console.log('üéµ Sistema de audio inicializado');
        } catch (error) {
            console.warn('‚ùå Audio no disponible:', error);
            this.isInitialized = false;
        }
    }

    // Activar/desactivar m√∫sica
    toggleMusic() {
        this.musicEnabled = !this.musicEnabled;
        
        if (!this.musicEnabled && this.musicTimeout) {
            clearTimeout(this.musicTimeout);
            this.musicTimeout = null;
        }
        
        return this.musicEnabled;
    }

    // Activar/desactivar efectos de sonido
    toggleSoundEffects() {
        this.soundEffectsEnabled = !this.soundEffectsEnabled;
        return this.soundEffectsEnabled;
    }

    // Ajustar volumen maestro
    setMasterVolume(volume) {
        this.masterVolume = Math.max(0, Math.min(1, volume));
    }

    // Reproducir nota musical
    playNote(frequency, startTime, duration, volume = 0.1) {
        if (!this.isInitialized || !this.audioContext) return;

        try {
            const oscillator = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(this.audioContext.destination);
            
            oscillator.frequency.setValueAtTime(frequency, startTime);
            oscillator.type = 'square'; // Sonido retro como el Tetris original
            
            const finalVolume = volume * this.musicVolume * this.masterVolume;
            
            gainNode.gain.setValueAtTime(0, startTime);
            gainNode.gain.linearRampToValueAtTime(finalVolume, startTime + 0.01);
            gainNode.gain.linearRampToValueAtTime(finalVolume * 0.8, startTime + duration - 0.05);
            gainNode.gain.linearRampToValueAtTime(0, startTime + duration);
            
            oscillator.start(startTime);
            oscillator.stop(startTime + duration);
        } catch (error) {
            console.warn('Error reproduciendo nota:', error);
        }
    }

    // M√öSICA CL√ÅSICA DEL TETRIS (Korobeiniki)
    playTetrisMusic() {
        if (!this.musicEnabled || !this.isInitialized || !this.audioContext) return;

        // Melod√≠a completa del Tetris (m√°s notas que antes)
        const melody = [
            // Primera secci√≥n
            { freq: 659.25, duration: 0.4 }, // E5
            { freq: 493.88, duration: 0.2 }, // B4
            { freq: 523.25, duration: 0.2 }, // C5
            { freq: 587.33, duration: 0.4 }, // D5
            { freq: 523.25, duration: 0.2 }, // C5
            { freq: 493.88, duration: 0.2 }, // B4
            { freq: 440.00, duration: 0.4 }, // A4
            { freq: 440.00, duration: 0.2 }, // A4
            { freq: 523.25, duration: 0.2 }, // C5
            { freq: 659.25, duration: 0.4 }, // E5
            { freq: 587.33, duration: 0.2 }, // D5
            { freq: 523.25, duration: 0.2 }, // C5
            { freq: 493.88, duration: 0.6 }, // B4
            { freq: 523.25, duration: 0.2 }, // C5
            { freq: 587.33, duration: 0.4 }, // D5
            { freq: 659.25, duration: 0.4 }, // E5
            { freq: 523.25, duration: 0.4 }, // C5
            { freq: 440.00, duration: 0.4 }, // A4
            { freq: 440.00, duration: 0.8 }, // A4 (m√°s larga)
            
            { freq: 0, duration: 0.2 }, // Pausa
            
            // Segunda secci√≥n
            { freq: 587.33, duration: 0.4 }, // D5
            { freq: 698.46, duration: 0.2 }, // F5
            { freq: 880.00, duration: 0.4 }, // A5
            { freq: 783.99, duration: 0.2 }, // G5
            { freq: 698.46, duration: 0.2 }, // F5
            { freq: 659.25, duration: 0.6 }, // E5
            { freq: 523.25, duration: 0.2 }, // C5
            { freq: 659.25, duration: 0.4 }, // E5
            { freq: 587.33, duration: 0.2 }, // D5
            { freq: 523.25, duration: 0.2 }, // C5
            { freq: 493.88, duration: 0.4 }, // B4
            { freq: 493.88, duration: 0.2 }, // B4
            { freq: 523.25, duration: 0.2 }, // C5
            { freq: 587.33, duration: 0.4 }, // D5
            { freq: 659.25, duration: 0.4 }, // E5
            { freq: 523.25, duration: 0.4 }, // C5
            { freq: 440.00, duration: 0.4 }, // A4
            { freq: 440.00, duration: 0.8 }  // A4 (final)
        ];

        const currentTime = this.audioContext.currentTime;
        let totalTime = 0;

        // Reproducir cada nota
        melody.forEach((note) => {
            if (note.freq > 0) {
                this.playNote(note.freq, currentTime + totalTime, note.duration);
            }
            totalTime += note.duration;
        });

        // Programar repetici√≥n de la m√∫sica
        if (this.musicEnabled) {
            this.musicTimeout = setTimeout(() => {
                if (this.musicEnabled) {
                    this.playTetrisMusic();
                }
            }, GAME_CONFIG.MUSIC_REPEAT_INTERVAL);
        }
    }

    // Detener m√∫sica
    stopMusic() {
        if (this.musicTimeout) {
            clearTimeout(this.musicTimeout);
            this.musicTimeout = null;
        }
    }

    // EFECTOS DE SONIDO

    // Sonido de respuesta correcta
    playCorrectSound() {
        if (!this.soundEffectsEnabled || !this.isInitialized) return;

        try {
            const currentTime = this.audioContext.currentTime;
            const finalVolume = this.effectsVolume * this.masterVolume;

            // Acorde ascendente alegre
            [0, 0.1, 0.2].forEach((delay, index) => {
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                const frequencies = [523.25, 659.25, 783.99]; // C5, E5, G5
                oscillator.frequency.setValueAtTime(frequencies[index], currentTime + delay);
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0, currentTime + delay);
                gainNode.gain.linearRampToValueAtTime(finalVolume * 0.4, currentTime + delay + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, currentTime + delay + 0.3);
                
                oscillator.start(currentTime + delay);
                oscillator.stop(currentTime + delay + 0.3);
            });
        } catch (error) {
            console.warn('Error en sonido correcto:', error);
        }
    }

    // Sonido de respuesta incorrecta
    playIncorrectSound() {
        if (!this.soundEffectsEnabled || !this.isInitialized) return;

        try {
            const currentTime = this.audioContext.currentTime;
            const oscillator = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(this.audioContext.destination);
            
            const finalVolume = this.effectsVolume * this.masterVolume;
            
            // Sonido descendente de error
            oscillator.frequency.setValueAtTime(400, currentTime);
            oscillator.frequency.linearRampToValueAtTime(200, currentTime + 0.4);
            oscillator.type = 'sawtooth';
            
            gainNode.gain.setValueAtTime(0, currentTime);
            gainNode.gain.linearRampToValueAtTime(finalVolume * 0.3, currentTime + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.001, currentTime + 0.4);
            
            oscillator.start(currentTime);
            oscillator.stop(currentTime + 0.4);
        } catch (error) {
            console.warn('Error en sonido incorrecto:', error);
        }
    }

    // Sonido de subida de nivel
    playLevelUpSound() {
        if (!this.soundEffectsEnabled || !this.isInitialized) return;

        try {
            const currentTime = this.audioContext.currentTime;
            const finalVolume = this.effectsVolume * this.masterVolume;

            // Fanfarria de nivel
            const levelUpMelody = [
                { freq: 523.25, time: 0.0, duration: 0.15 }, // C5
                { freq: 659.25, time: 0.1, duration: 0.15 }, // E5
                { freq: 783.99, time: 0.2, duration: 0.15 }, // G5
                { freq: 1046.5, time: 0.3, duration: 0.25 }  // C6
            ];

            levelUpMelody.forEach(note => {
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.setValueAtTime(note.freq, currentTime + note.time);
                oscillator.type = 'triangle';
                
                gainNode.gain.setValueAtTime(0, currentTime + note.time);
                gainNode.gain.linearRampToValueAtTime(finalVolume * 0.5, currentTime + note.time + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, currentTime + note.time + note.duration);
                
                oscillator.start(currentTime + note.time);
                oscillator.stop(currentTime + note.time + note.duration);
            });
        } catch (error) {
            console.warn('Error en sonido de nivel:', error);
        }
    }

    // Sonido de racha
    playStreakSound(streakCount) {
        if (!this.soundEffectsEnabled || !this.isInitialized) return;

        try {
            const currentTime = this.audioContext.currentTime;
            const finalVolume = this.effectsVolume * this.masterVolume;

            // Sonidos m√°s intensos para rachas m√°s altas
            const intensity = Math.min(streakCount / 10, 1);
            const baseFreq = 440 + (streakCount * 20);

            for (let i = 0; i < 3; i++) {
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.setValueAtTime(baseFreq * (1 + i * 0.5), currentTime + i * 0.1);
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0, currentTime + i * 0.1);
                gainNode.gain.linearRampToValueAtTime(finalVolume * 0.3 * intensity, currentTime + i * 0.1 + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, currentTime + i * 0.1 + 0.2);
                
                oscillator.start(currentTime + i * 0.1);
                oscillator.stop(currentTime + i * 0.1 + 0.2);
            }
        } catch (error) {
            console.warn('Error en sonido de racha:', error);
        }
    }

    // Sonido de Game Over
    playGameOverSound() {
        if (!this.soundEffectsEnabled || !this.isInitialized) return;

        try {
            const currentTime = this.audioContext.currentTime;
            const finalVolume = this.effectsVolume * this.masterVolume;

            // Melod√≠a triste descendente
            const gameOverMelody = [
                { freq: 523.25, time: 0.0, duration: 0.3 }, // C5
                { freq: 493.88, time: 0.3, duration: 0.3 }, // B4
                { freq: 440.00, time: 0.6, duration: 0.3 }, // A4
                { freq: 392.00, time: 0.9, duration: 0.5 }  // G4
            ];

            gameOverMelody.forEach(note => {
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.setValueAtTime(note.freq, currentTime + note.time);
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0, currentTime + note.time);
                gainNode.gain.linearRampToValueAtTime(finalVolume * 0.4, currentTime + note.time + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, currentTime + note.time + note.duration);
                
                oscillator.start(currentTime + note.time);
                oscillator.stop(currentTime + note.time + note.duration);
            });
        } catch (error) {
            console.warn('Error en sonido game over:', error);
        }
    }

    // Obtener estado del audio
    getAudioState() {
        return {
            musicEnabled: this.musicEnabled,
            soundEffectsEnabled: this.soundEffectsEnabled,
            masterVolume: this.masterVolume,
            isInitialized: this.isInitialized
        };
    }
}

// INSTANCIA GLOBAL DEL ADMINISTRADOR DE AUDIO
const AudioManager_Instance = new AudioManager();

// FUNCIONES GLOBALES PARA USO F√ÅCIL
function initAudio() {
    AudioManager_Instance.init();
}

function toggleMusic() {
    return AudioManager_Instance.toggleMusic();
}

function toggleSoundEffects() {
    return AudioManager_Instance.toggleSoundEffects();
}

function playTetrisMusic() {
    AudioManager_Instance.playTetrisMusic();
}

function stopMusic() {
    AudioManager_Instance.stopMusic();
}

function playCorrectSound() {
    AudioManager_Instance.playCorrectSound();
}

function playIncorrectSound() {
    AudioManager_Instance.playIncorrectSound();
}

function playLevelUpSound() {
    AudioManager_Instance.playLevelUpSound();
}

function playStreakSound(streakCount) {
    AudioManager_Instance.playStreakSound(streakCount);
}

function playGameOverSound() {
    AudioManager_Instance.playGameOverSound();
}

function getAudioState() {
    return AudioManager_Instance.getAudioState();
}

// EXPORTAR (para uso con m√≥dulos)
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        AudioManager,
        initAudio,
        toggleMusic,
        toggleSoundEffects,
        playTetrisMusic,
        stopMusic,
        playCorrectSound,
        playIncorrectSound,
        playLevelUpSound,
        playStreakSound,
        playGameOverSound,
        getAudioState
    };
}
// CONFIGURACI√ìN PRINCIPAL DEL TETRIS BALANCE

// Configuraci√≥n del juego
const GAME_CONFIG = {
    // Velocidades (en milisegundos)
    INITIAL_FALL_SPEED: 8000,        // 8 segundos iniciales
    MIN_FALL_SPEED: 3000,            // Velocidad m√≠nima (3 segundos)
    SPEED_DECREASE_PER_LEVEL: 800,   // Reduce 0.8s por nivel
    
    // Puntuaci√≥n
    BASE_POINTS: 10,                 // Puntos base por acierto
    STREAK_BONUS_THRESHOLD: 5,       // A partir de qu√© racha dar bonus
    STREAK_BONUS_MULTIPLIER: 10,     // Multiplicador del bonus por racha
    LEVEL_UP_POINTS: 150,            // Puntos necesarios por nivel
    
    // Vidas y tiempo
    INITIAL_LIVES: 3,
    FEEDBACK_DURATION: 3000,         // 3 segundos de feedback
    
    // Posicionamiento
    MIN_ELEMENT_POSITION: 15,        // 15% del ancho m√≠nimo
    MAX_ELEMENT_POSITION: 85,        // 85% del ancho m√°ximo
    MOVEMENT_STEP: 12,               // Paso de movimiento (12%)
    
    // Temporizadores
    TIMER_INTERVAL: 100,             // Actualizaci√≥n cada 100ms
    MUSIC_DELAY: 1000,               // Delay inicial de m√∫sica
    MUSIC_REPEAT_INTERVAL: 18000     // Repetir m√∫sica cada 18s
};

// ELEMENTOS DEL BALANCE (30 elementos educativos)
const BALANCE_ELEMENTS = [
    // ACTIVO CORRIENTE (bienes que se convierten en dinero < 1 a√±o)
    { 
        name: 'Existencias', 
        category: 'activo-corriente', 
        color: 'bg-green-400', 
        icon: 'üì¶',
        tip: 'Mercader√≠as, materias primas y productos que la empresa tiene para vender'
    },
    { 
        name: 'Clientes', 
        category: 'activo-corriente', 
        color: 'bg-green-400', 
        icon: 'üë•',
        tip: 'Personas o empresas que nos deben dinero por ventas a cr√©dito'
    },
    { 
        name: 'Bancos', 
        category: 'activo-corriente', 
        color: 'bg-green-400', 
        icon: 'üèõÔ∏è',
        tip: 'Dinero que tenemos depositado en cuentas bancarias'
    },
    { 
        name: 'Caja', 
        category: 'activo-corriente', 
        color: 'bg-green-400', 
        icon: 'üíµ',
        tip: 'Dinero en efectivo que tiene la empresa'
    },
    { 
        name: 'IVA Soportado', 
        category: 'activo-corriente', 
        color: 'bg-green-400', 
        icon: 'üìä',
        tip: 'IVA que hemos pagado en nuestras compras y podemos recuperar'
    },
    { 
        name: 'Deudores', 
        category: 'activo-corriente', 
        color: 'bg-green-400', 
        icon: 'üë§',
        tip: 'Personas que nos deben dinero por conceptos distintos a las ventas'
    },
    { 
        name: 'H.P. Deudora', 
        category: 'activo-corriente', 
        color: 'bg-green-400', 
        icon: 'üèõÔ∏è',
        tip: 'Hacienda P√∫blica nos debe dinero (devoluciones, subvenciones)'
    },
    { 
        name: 'Efectos a Cobrar', 
        category: 'activo-corriente', 
        color: 'bg-green-400', 
        icon: 'üìã',
        tip: 'Letras de cambio y pagar√©s que tenemos pendientes de cobro'
    },
    { 
        name: 'Inversiones Financieras C/P', 
        category: 'activo-corriente', 
        color: 'bg-green-400', 
        icon: 'üíπ',
        tip: 'Inversiones que podemos convertir en dinero en menos de un a√±o'
    },

    // ACTIVO NO CORRIENTE (bienes permanentes > 1 a√±o)
    { 
        name: 'Inmovilizado Material', 
        category: 'activo-no-corriente', 
        color: 'bg-blue-400', 
        icon: 'üè¢',
        tip: 'Bienes f√≠sicos que duran m√°s de un a√±o: edificios, maquinaria, etc.'
    },
    { 
        name: 'Terrenos', 
        category: 'activo-no-corriente', 
        color: 'bg-blue-400', 
        icon: 'üèûÔ∏è',
        tip: 'Solares y terrenos propiedad de la empresa'
    },
    { 
        name: 'Construcciones', 
        category: 'activo-no-corriente', 
        color: 'bg-blue-400', 
        icon: 'üèóÔ∏è',
        tip: 'Edificios, naves industriales y otras construcciones'
    },
    { 
        name: 'Maquinaria', 
        category: 'activo-no-corriente', 
        color: 'bg-blue-400', 
        icon: '‚öôÔ∏è',
        tip: 'M√°quinas y equipos de producci√≥n de la empresa'
    },
    { 
        name: 'Mobiliario', 
        category: 'activo-no-corriente', 
        color: 'bg-blue-400', 
        icon: 'ü™ë',
        tip: 'Muebles y enseres de oficina que duran varios a√±os'
    },
    { 
        name: 'Equipos Inform√°ticos', 
        category: 'activo-no-corriente', 
        color: 'bg-blue-400', 
        icon: 'üíª',
        tip: 'Ordenadores y equipos tecnol√≥gicos de uso prolongado'
    },
    { 
        name: 'Elementos de Transporte', 
        category: 'activo-no-corriente', 
        color: 'bg-blue-400', 
        icon: 'üöõ',
        tip: 'Veh√≠culos y medios de transporte de la empresa'
    },
    { 
        name: 'Inversiones Financieras L/P', 
        category: 'activo-no-corriente', 
        color: 'bg-blue-400', 
        icon: 'üìà',
        tip: 'Inversiones que mantendremos m√°s de un a√±o'
    },
    { 
        name: 'Amortizaci√≥n Acumulada', 
        category: 'activo-no-corriente', 
        color: 'bg-blue-300', 
        icon: 'üìâ',
        tip: 'P√©rdida de valor acumulada del inmovilizado (resta al activo)'
    },

    // PASIVO CORRIENTE (deudas < 1 a√±o)
    { 
        name: 'Proveedores', 
        category: 'pasivo-corriente', 
        color: 'bg-red-400', 
        icon: 'üè™',
        tip: 'Dinero que debemos a proveedores por compras a cr√©dito'
    },
    { 
        name: 'Pr√©stamos C/P', 
        category: 'pasivo-corriente', 
        color: 'bg-red-400', 
        icon: 'üìÑ',
        tip: 'Pr√©stamos y deudas que debemos pagar en menos de un a√±o'
    },
    { 
        name: 'Acreedores', 
        category: 'pasivo-corriente', 
        color: 'bg-red-400', 
        icon: 'üí≥',
        tip: 'Deudas con terceros por servicios recibidos'
    },
    { 
        name: 'IVA Repercutido', 
        category: 'pasivo-corriente', 
        color: 'bg-red-400', 
        icon: 'üìà',
        tip: 'IVA que hemos cobrado en ventas y debemos entregar a Hacienda'
    },
    { 
        name: 'H.P. Acreedora', 
        category: 'pasivo-corriente', 
        color: 'bg-red-400', 
        icon: 'üèõÔ∏è',
        tip: 'Dinero que debemos a Hacienda P√∫blica (impuestos pendientes)'
    },
    { 
        name: 'Anticipos de Clientes', 
        category: 'pasivo-corriente', 
        color: 'bg-red-400', 
        icon: 'üí∏',
        tip: 'Dinero que nos han pagado los clientes por adelantado'
    },
    { 
        name: 'Efectos a Pagar', 
        category: 'pasivo-corriente', 
        color: 'bg-red-400', 
        icon: 'üìã',
        tip: 'Letras de cambio y pagar√©s que debemos pagar'
    },
    { 
        name: 'Sueldos Pendientes', 
        category: 'pasivo-corriente', 
        color: 'bg-red-400', 
        icon: 'üë∑',
        tip: 'Salarios devengados pero a√∫n no pagados a los trabajadores'
    },
    { 
        name: 'Seguridad Social Acreedora', 
        category: 'pasivo-corriente', 
        color: 'bg-red-400', 
        icon: 'üè•',
        tip: 'Cotizaciones a la Seguridad Social pendientes de pago'
    },

    // PASIVO NO CORRIENTE (deudas > 1 a√±o)
    { 
        name: 'Pr√©stamos L/P', 
        category: 'pasivo-no-corriente', 
        color: 'bg-orange-400', 
        icon: 'üìã',
        tip: 'Pr√©stamos y deudas con vencimiento superior a un a√±o'
    },
    { 
        name: 'Deudas L/P', 
        category: 'pasivo-no-corriente', 
        color: 'bg-orange-400', 
        icon: 'üìú',
        tip: 'Otras deudas a largo plazo con terceros'
    },

    // FONDOS PROPIOS (recursos propios de la empresa)
    { 
        name: 'Capital Social', 
        category: 'fondos-propios', 
        color: 'bg-purple-400', 
        icon: 'üí∞',
        tip: 'Dinero que han aportado los socios o accionistas'
    },
    { 
        name: 'Reservas', 
        category: 'fondos-propios', 
        color: 'bg-purple-400', 
        icon: 'üè¶',
        tip: 'Beneficios de a√±os anteriores que se quedaron en la empresa'
    },
    { 
        name: 'Resultado del Ejercicio', 
        category: 'fondos-propios', 
        color: 'bg-purple-400', 
        icon: 'üìä',
        tip: 'Beneficio o p√©rdida obtenida durante el a√±o actual'
    }
];

// CATEGOR√çAS DEL BALANCE
const CATEGORIES = {
    'activo-corriente': { 
        name: 'Activo Corriente',
        shortName: 'A.C.',
        color: 'bg-green-100 border-green-400', 
        textColor: 'text-green-800',
        description: 'Bienes y derechos que se convierten en dinero en menos de un a√±o',
        examples: 'Existencias, Clientes, Bancos, Caja...'
    },
    'activo-no-corriente': { 
        name: 'Activo No Corriente',
        shortName: 'A.N.C.',
        color: 'bg-blue-100 border-blue-400', 
        textColor: 'text-blue-800',
        description: 'Bienes y derechos de car√°cter permanente (m√°s de un a√±o)',
        examples: 'Terrenos, Construcciones, Maquinaria...'
    },
    'pasivo-corriente': { 
        name: 'Pasivo Corriente',
        shortName: 'P.C.',
        color: 'bg-red-100 border-red-400', 
        textColor: 'text-red-800',
        description: 'Deudas y obligaciones con vencimiento inferior a un a√±o',
        examples: 'Proveedores, Pr√©stamos C/P, Acreedores...'
    },
    'pasivo-no-corriente': { 
        name: 'Pasivo No Corriente',
        shortName: 'P.N.C.',
        color: 'bg-orange-100 border-orange-400', 
        textColor: 'text-orange-800',
        description: 'Deudas y obligaciones con vencimiento superior a un a√±o',
        examples: 'Pr√©stamos L/P, Deudas L/P...'
    },
    'fondos-propios': { 
        name: 'Fondos Propios',
        shortName: 'F.P.',
        color: 'bg-purple-100 border-purple-400', 
        textColor: 'text-purple-800',
        description: 'Recursos propios de la empresa (capital y reservas)',
        examples: 'Capital Social, Reservas, Resultado...'
    }
};

// CONFIGURACI√ìN DE CALIFICACIONES
const GRADING_SYSTEM = {
    'S': { 
        minScore: 500, 
        message: '¬°Maestro del Balance!', 
        color: 'text-yellow-400', 
        emoji: 'üëë',
        description: 'Conocimiento excepcional de contabilidad'
    },
    'A+': { 
        minScore: 350, 
        message: '¬°Excelente dominio!', 
        color: 'text-green-400', 
        emoji: 'üèÜ',
        description: 'Dominas perfectamente el balance'
    },
    'A': { 
        minScore: 250, 
        message: '¬°Muy buen trabajo!', 
        color: 'text-green-300', 
        emoji: '‚≠ê',
        description: 'Tienes un gran conocimiento'
    },
    'B+': { 
        minScore: 180, 
        message: 'Buen desempe√±o', 
        color: 'text-blue-400', 
        emoji: 'üëç',
        description: 'Vas por buen camino'
    },
    'B': { 
        minScore: 120, 
        message: 'Progreso adecuado', 
        color: 'text-blue-300', 
        emoji: 'üìö',
        description: 'Sigue practicando as√≠'
    },
    'C': { 
        minScore: 70, 
        message: 'Necesitas m√°s pr√°ctica', 
        color: 'text-yellow-300', 
        emoji: 'üìñ',
        description: 'Repasa los conceptos b√°sicos'
    },
    'D': { 
        minScore: 0, 
        message: 'Sigue intentando', 
        color: 'text-red-300', 
        emoji: 'üí™',
        description: 'No te rindas, practica m√°s'
    }
};

// MENSAJES MOTIVACIONALES
const MOTIVATIONAL_MESSAGES = {
    firstCorrect: ['¬°Buen comienzo!', '¬°As√≠ se hace!', '¬°Perfecto!'],
    streak3: ['¬°Vas bien!', '¬°Sigue as√≠!', '¬°Excelente!'],
    streak5: ['¬°Racha fant√°stica!', 'üî• ¬°Imparable!', '¬°Incre√≠ble dominio!'],
    streak10: ['üöÄ ¬°LEYENDA!', 'üëë ¬°MAESTRO!', 'üèÜ ¬°FEN√ìMENO!'],
    levelUp: ['üéâ ¬°Nivel superado!', '‚¨ÜÔ∏è ¬°Subiendo de nivel!', 'üåü ¬°Progreso!'],
    almostGameOver: ['¬°Cuidado!', '‚ö†Ô∏è ¬°√öltima oportunidad!', 'üí™ ¬°T√∫ puedes!']
};

// EXPORTAR (para uso con m√≥dulos)
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        GAME_CONFIG,
        BALANCE_ELEMENTS,
        CATEGORIES,
        GRADING_SYSTEM,
        MOTIVATIONAL_MESSAGES
    };
}
// L√ìGICA PRINCIPAL DEL TETRIS BALANCE

// CLASE PRINCIPAL DEL JUEGO
class TetrisBalanceGame {
    constructor() {
        // Estados del juego
        this.gameState = {
            isPlaying: false,
            isPaused: false,
            gameOver: false,
            currentElement: null,
            isElementFalling: false,
            isDragging: false
        };

        // Estad√≠sticas
        this.stats = {
            score: 0,
            level: 1,
            lives: GAME_CONFIG.INITIAL_LIVES,
            streak: 0,
            bestStreak: 0,
            totalAttempts: 0,
            correctAnswers: 0
        };

        // Configuraci√≥n din√°mica
        this.config = {
            fallSpeed: GAME_CONFIG.INITIAL_FALL_SPEED,
            elementPosition: 50, // Posici√≥n horizontal del elemento (0-100%)
            fallTimer: 0
        };

        // Feedback y UI
        this.ui = {
            feedback: '',
            showFeedback: false,
            activeSlot: null,
            categoryStats: {}
        };

        // Referencias y temporizadores
        this.refs = {
            gameAreaRef: null,
            fallInterval: null,
            gameInterval: null
        };

        // Eventos del mouse/touch
        this.mouse = {
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0
        };

        // Bind de m√©todos
        this.handleMouseMove = this.handleMouseMove.bind(this);
        this.handleMouseUp = this.handleMouseUp.bind(this);
        this.handleTouchMove = this.handleTouchMove.bind(this);
        this.handleTouchEnd = this.handleTouchEnd.bind(this);
    }

    // INICIALIZAR JUEGO
    initGame() {
        console.log('üéÆ Inicializando Tetris Balance...');
        
        // Inicializar audio
        initAudio();
        
        // Configurar eventos globales
        this.setupEventListeners();
        
        console.log('‚úÖ Juego inicializado correctamente');
    }

    // CONFIGURAR EVENT LISTENERS
    setupEventListeners() {
        // Eventos de teclado
        document.addEventListener('keydown', (e) => {
            this.handleKeyPress(e);
        });

        // Eventos de visibilidad (pausar cuando se cambia de pesta√±a)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && this.gameState.isPlaying && !this.gameState.isPaused) {
                this.pauseGame();
            }
        });
    }

    // GENERAR NUEVO ELEMENTO
    generateNewElement() {
        // Seleccionar elemento aleatorio
        const randomIndex = Math.floor(Math.random() * BALANCE_ELEMENTS.length);
        const element = BALANCE_ELEMENTS[randomIndex];
        
        // Configurar nuevo elemento
        this.gameState.currentElement = element;
        this.gameState.isElementFalling = true;
        this.gameState.isDragging = false;
        
        // Posici√≥n aleatoria pero centrada
        this.config.elementPosition = Math.random() * 40 + 30; // Entre 30% y 70%
        this.config.fallTimer = 0;

        console.log(`üéØ Nuevo elemento: ${element.name} (${element.category})`);
    }

    // INICIAR JUEGO
    startGame() {
        console.log('üöÄ Iniciando juego...');
        
        // Resetear estados
        this.gameState = {
            isPlaying: true,
            isPaused: false,
            gameOver: false,
            currentElement: null,
            isElementFalling: false,
            isDragging: false
        };

        // Resetear estad√≠sticas
        this.stats = {
            score: 0,
            level: 1,
            lives: GAME_CONFIG.INITIAL_LIVES,
            streak: 0,
            bestStreak: 0,
            totalAttempts: 0,
            correctAnswers: 0
        };

        // Resetear configuraci√≥n
        this.config = {
            fallSpeed: GAME_CONFIG.INITIAL_FALL_SPEED,
            elementPosition: 50,
            fallTimer: 0
        };

        // Resetear UI
        this.ui = {
            feedback: '',
            showFeedback: false,
            activeSlot: null,
            categoryStats: {}
        };

        // Generar primer elemento
        this.generateNewElement();
        
        // Iniciar bucle de juego
        this.startGameLoop();
        
        // Iniciar m√∫sica si est√° habilitada
        const audioState = getAudioState();
        if (audioState.musicEnabled) {
            setTimeout(() => {
                playTetrisMusic();
            }, GAME_CONFIG.MUSIC_DELAY);
        }
    }

    // PAUSAR/REANUDAR JUEGO
    togglePause() {
        if (!this.gameState.isPlaying) return;

        this.gameState.isPaused = !this.gameState.isPaused;
        
        if (this.gameState.isPaused) {
            this.pauseGame();
        } else {
            this.resumeGame();
        }
    }

    pauseGame() {
        this.gameState.isPaused = true;
        this.clearIntervals();
        stopMusic();
        console.log('‚è∏Ô∏è Juego pausado');
    }

    resumeGame() {
        this.gameState.isPaused = false;
        this.startGameLoop();
        
        const audioState = getAudioState();
        if (audioState.musicEnabled) {
            playTetrisMusic();
        }
        console.log('‚ñ∂Ô∏è Juego reanudado');
    }

    // REINICIAR JUEGO
    resetGame() {
        console.log('üîÑ Reiniciando juego...');
        
        this.gameState.isPlaying = false;
        this.gameState.isPaused = false;
        this.gameState.gameOver = false;
        this.gameState.currentElement = null;
        this.gameState.isElementFalling = false;
        this.gameState.isDragging = false;
        
        this.clearIntervals();
        stopMusic();
    }

    // BUCLE PRINCIPAL DEL JUEGO
    startGameLoop() {
        if (this.gameState.isPaused || !this.gameState.isPlaying) return;

        this.refs.fallInterval = setInterval(() => {
            if (this.gameState.isElementFalling && !this.ui.showFeedback && !this.gameState.isDragging) {
                this.updateFallTimer();
            }
        }, GAME_CONFIG.TIMER_INTERVAL);
    }

    // ACTUALIZAR TEMPORIZADOR DE CA√çDA
    updateFallTimer() {
        this.config.fallTimer += GAME_CONFIG.TIMER_INTERVAL;
        
        if (this.config.fallTimer >= this.config.fallSpeed) {
            this.handleElementFall();
        }
    }

    // MANEJAR CA√çDA AUTOM√ÅTICA DEL ELEMENTO
    handleElementFall() {
        if (!this.gameState.isElementFalling || this.ui.showFeedback) return;

        console.log('‚è∞ Elemento se escap√≥');
        
        this.stats.lives--;
        this.stats.streak = 0;
        this.stats.totalAttempts++;
        
        this.gameState.isElementFalling = false;
        
        this.ui.feedback = `‚è∞ ¬°Se escap√≥! ${this.gameState.currentElement.name} pertenece a ${CATEGORIES[this.gameState.currentElement.category].name}`;
        this.ui.showFeedback = true;
        
        playIncorrectSound();
        
        setTimeout(() => {
            this.processFeedbackEnd();
        }, GAME_CONFIG.FEEDBACK_DURATION);
    }

    // MOVER ELEMENTO CON TECLADO
    moveElement(direction) {
        if (!this.gameState.isPlaying || this.gameState.isPaused || 
            !this.gameState.isElementFalling || this.gameState.isDragging) return;

        const step = GAME_CONFIG.MOVEMENT_STEP;
        
        if (direction === 'left') {
            this.config.elementPosition = Math.max(
                GAME_CONFIG.MIN_ELEMENT_POSITION, 
                this.config.elementPosition - step
            );
        } else if (direction === 'right') {
            this.config.elementPosition = Math.min(
                GAME_CONFIG.MAX_ELEMENT_POSITION, 
                this.config.elementPosition + step
            );
        }
    }

    // MANEJO DE MOUSE/TOUCH - INICIO
    handleMouseDown(e) {
        if (!this.gameState.isElementFalling || this.ui.showFeedback) return;
        
        this.gameState.isDragging = true;
        
        // Obtener posici√≥n inicial
        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
        const clientY = e.clientY || (e.touches && e.touches[0].clientY);
        
        this.mouse.startX = clientX;
        this.mouse.startY = clientY;
        this.mouse.currentX = clientX;
        this.mouse.currentY = clientY;
        
        // Prevenir comportamientos por defecto
        e.preventDefault();
        
        // A√±adir event listeners globales
        document.addEventListener('mousemove', this.handleMouseMove);
        document.addEventListener('mouseup', this.handleMouseUp);
        document.addEventListener('touchmove', this.handleTouchMove, { passive: false });
        document.addEventListener('touchend', this.handleTouchEnd);
        
        console.log('üñ±Ô∏è Iniciado arrastre del elemento');
    }

    // MANEJO DE MOUSE - MOVIMIENTO
    handleMouseMove(e) {
        if (!this.gameState.isDragging || !this.refs.gameAreaRef) return;
        
        const rect = this.refs.gameAreaRef.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const percentage = (x / rect.width) * 100;
        
        this.config.elementPosition = Math.max(
            GAME_CONFIG.MIN_ELEMENT_POSITION,
            Math.min(GAME_CONFIG.MAX_ELEMENT_POSITION, percentage)
        );
        
        e.preventDefault();
    }

    // MANEJO DE TOUCH - MOVIMIENTO
    handleTouchMove(e) {
        if (!this.gameState.isDragging || !this.refs.gameAreaRef) return;
        
        const touch = e.touches[0];
        const rect = this.refs.gameAreaRef.getBoundingClientRect();
        const x = touch.clientX - rect.left;
        const percentage = (x / rect.width) * 100;
        
        this.config.elementPosition = Math.max(
            GAME_CONFIG.MIN_ELEMENT_POSITION,
            Math.min(GAME_CONFIG.MAX_ELEMENT_POSITION, percentage)
        );
        
        e.preventDefault();
    }

    // MANEJO DE MOUSE/TOUCH - FIN
    handleMouseUp(e) {
        if (!this.gameState.isDragging) return;
        
        this.gameState.isDragging = false;
        
        // Remover event listeners
        document.removeEventListener('mousemove', this.handleMouseMove);
        document.removeEventListener('mouseup', this.handleMouseUp);
        document.removeEventListener('touchmove', this.handleTouchMove);
        document.removeEventListener('touchend', this.handleTouchEnd);
        
        console.log('üñ±Ô∏è Finalizado arrastre del elemento');
    }

    handleTouchEnd(e) {
        this.handleMouseUp(e);
    }

    // MANEJAR CLASIFICACI√ìN DE ELEMENTO
    handleCategoryDrop(selectedCategory) {
        if (!this.gameState.isElementFalling || !this.gameState.currentElement || this.ui.showFeedback) {
            return;
        }

        console.log(`üéØ Clasificando ${this.gameState.currentElement.name} en ${selectedCategory}`);
        
        // Detener ca√≠da y arrastre
        this.ui.activeSlot = selectedCategory;
        this.gameState.isElementFalling = false;
        this.gameState.isDragging = false;
        this.clearIntervals();
        
        // Verificar respuesta
        const isCorrect = selectedCategory === this.gameState.currentElement.category;
        
        // Actualizar estad√≠sticas generales
        this.stats.totalAttempts++;
        
        if (isCorrect) {
            this.handleCorrectAnswer();
        } else {
            this.handleIncorrectAnswer();
        }
        
        // Actualizar estad√≠sticas por categor√≠a
        this.updateCategoryStats(selectedCategory, isCorrect);
        
        // Mostrar feedback
        this.ui.showFeedback = true;
        
        // Programar fin del feedback
        setTimeout(() => {
            this.processFeedbackEnd();
        }, GAME_CONFIG.FEEDBACK_DURATION);
    }

    // MANEJAR RESPUESTA CORRECTA
    handleCorrectAnswer() {
        const pointsEarned = GAME_CONFIG.BASE_POINTS * this.stats.level;
        
        this.stats.score += pointsEarned;
        this.stats.correctAnswers++;
        this.stats.streak++;
        
        if (this.stats.streak > this.stats.bestStreak) {
            this.stats.bestStreak = this.stats.streak;
        }
        
        let feedbackText = `¬°Correcto! +${pointsEarned} puntos`;
        
        // Bonificaci√≥n por racha
        if (this.stats.streak >= GAME_CONFIG.STREAK_BONUS_THRESHOLD) {
            const bonus = this.stats.streak * GAME_CONFIG.STREAK_BONUS_MULTIPLIER;
            this.stats.score += bonus;
            feedbackText += ` üî• ¬°Racha de ${this.stats.streak}! +${bonus} bonus`;
            
            playStreakSound(this.stats.streak);
        } else {
            playCorrectSound();
        }
        
        // Verificar subida de nivel
        const requiredScore = this.stats.level * GAME_CONFIG.LEVEL_UP_POINTS;
        if (this.stats.score >= requiredScore) {
            this.levelUp();
            feedbackText += ` üéâ ¬°Nivel ${this.stats.level}!`;
        }
        
        this.ui.feedback = feedbackText;
        
        console.log(`‚úÖ Respuesta correcta! Puntos: ${this.stats.score}, Racha: ${this.stats.streak}`);
    }

    // MANEJAR RESPUESTA INCORRECTA
    handleIncorrectAnswer() {
        this.stats.lives--;
        this.stats.streak = 0;
        
        this.ui.feedback = `‚ùå Incorrecto. ${this.gameState.currentElement.name} va en ${CATEGORIES[this.gameState.currentElement.category].name}`;
        
        playIncorrectSound();
        
        console.log(`‚ùå Respuesta incorrecta. Vidas restantes: ${this.stats.lives}`);
    }

    // SUBIR DE NIVEL
    levelUp() {
        this.stats.level++;
        this.config.fallSpeed = Math.max(
            GAME_CONFIG.MIN_FALL_SPEED,
            this.config.fallSpeed - GAME_CONFIG.SPEED_DECREASE_PER_LEVEL
        );
        
        playLevelUpSound();
        
        console.log(`üìà ¬°Nivel ${this.stats.level}! Nueva velocidad: ${this.config.fallSpeed}ms`);
    }

    // ACTUALIZAR ESTAD√çSTICAS POR CATEGOR√çA
    updateCategoryStats(category, isCorrect) {
        if (!this.ui.categoryStats[category]) {
            this.ui.categoryStats[category] = {
                attempts: 0,
                correct: 0
            };
        }
        
        this.ui.categoryStats[category].attempts++;
        if (isCorrect) {
            this.ui.categoryStats[category].correct++;
        }
    }

    // PROCESAR FIN DEL FEEDBACK
    processFeedbackEnd() {
        this.ui.showFeedback = false;
        this.ui.activeSlot = null;
        
        // Verificar fin del juego
        if (this.stats.lives <= 0) {
            this.endGame();
        } else {
            // Continuar con nuevo elemento
            this.generateNewElement();
            this.startGameLoop();
        }
    }

    // TERMINAR JUEGO
    endGame() {
        console.log('üéÆ Game Over!');
        
        this.gameState.gameOver = true;
        this.gameState.isPlaying = false;
        
        this.clearIntervals();
        stopMusic();
        playGameOverSound();
    }

    // MANEJAR TECLAS
    handleKeyPress(e) {
        if (!this.gameState.isPlaying || this.gameState.gameOver) return;
        
        switch(e.key.toLowerCase()) {
            case 'arrowleft':
            case 'a':
                e.preventDefault();
                this.moveElement('left');
                break;
                
            case 'arrowright':
            case 'd':
                e.preventDefault();
                this.moveElement('right');
                break;
                
            case ' ':
                e.preventDefault();
                this.togglePause();
                break;
                
            case '1':
                e.preventDefault();
                this.handleCategoryDrop('activo-corriente');
                break;
                
            case '2':
                e.preventDefault();
                this.handleCategoryDrop('activo-no-corriente');
                break;
                
            case '3':
                e.preventDefault();
                this.handleCategoryDrop('pasivo-corriente');
                break;
                
            case '4':
                e.preventDefault();
                this.handleCategoryDrop('pasivo-no-corriente');
                break;
                
            case '5':
                e.preventDefault();
                this.handleCategoryDrop('fondos-propios');
                break;
                
            case 'escape':
                e.preventDefault();
                this.resetGame();
                break;
                
            case 'm':
                e.preventDefault();
                this.toggleMusic();
                break;
                
            case 's':
                e.preventDefault();
                this.toggleSoundEffects();
                break;
        }
    }

    // ALTERNAR M√öSICA
    toggleMusic() {
        const newState = toggleMusic();
        
        if (newState && this.gameState.isPlaying && !this.gameState.isPaused) {
            playTetrisMusic();
        } else if (!newState) {
            stopMusic();
        }
        
        return newState;
    }

    // ALTERNAR EFECTOS DE SONIDO
    toggleSoundEffects() {
        return toggleSoundEffects();
    }

    // OBTENER CALIFICACI√ìN FINAL
    getFinalGrade() {
        const score = this.stats.score;
        
        for (const [grade, config] of Object.entries(GRADING_SYSTEM)) {
            if (score >= config.minScore) {
                return {
                    grade: grade,
                    ...config
                };
            }
        }
        
        return GRADING_SYSTEM['D'];
    }

    // CALCULAR PROGRESO DE CA√çDA
    getFallProgress() {
        if (!this.gameState.isElementFalling || this.gameState.isDragging) return 0;
        return (this.config.fallTimer / this.config.fallSpeed) * 100;
    }

    // OBTENER TIEMPO RESTANTE
    getTimeRemaining() {
        if (!this.gameState.isElementFalling) return 0;
        return Math.ceil((this.config.fallSpeed - this.config.fallTimer) / 1000);
    }

    // LIMPIAR INTERVALOS
    clearIntervals() {
        if (this.refs.fallInterval) {
            clearInterval(this.refs.fallInterval);
            this.refs.fallInterval = null;
        }
        
        if (this.refs.gameInterval) {
            clearInterval(this.refs.gameInterval);
            this.refs.gameInterval = null;
        }
    }

    // OBTENER ESTADO COMPLETO DEL JUEGO
    getGameState() {
        return {
            gameState: { ...this.gameState },
            stats: { ...this.stats },
            config: { ...this.config },
            ui: { ...this.ui },
            fallProgress: this.getFallProgress(),
            timeRemaining: this.getTimeRemaining(),
            finalGrade: this.gameState.gameOver ? this.getFinalGrade() : null,
            audioState: getAudioState()
        };
    }

    // DESTRUCTOR
    destroy() {
        this.clearIntervals();
        stopMusic();
        
        // Remover event listeners si existen
        document.removeEventListener('mousemove', this.handleMouseMove);
        document.removeEventListener('mouseup', this.handleMouseUp);
        document.removeEventListener('touchmove', this.handleTouchMove);
        document.removeEventListener('touchend', this.handleTouchEnd);
    }
}

// INSTANCIA GLOBAL DEL JUEGO
let gameInstance = null;

// FUNCIONES GLOBALES PARA USO F√ÅCIL
function initGameInstance() {
    if (gameInstance) {
        gameInstance.destroy();
    }
    gameInstance = new TetrisBalanceGame();
    gameInstance.initGame();
    return gameInstance;
}

function getGameInstance() {
    if (!gameInstance) {
        initGameInstance();
    }
    return gameInstance;
}

// EXPORTAR (para uso con m√≥dulos)
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        TetrisBalanceGame,
        initGameInstance,
        getGameInstance
    };
}
// COMPONENTES REACT DEL TETRIS BALANCE

const { useState, useEffect, useRef, useCallback } = React;

// ICONOS SVG
const Icons = {
    Play: () => React.createElement('svg', {
        className: "w-6 h-6",
        fill: "none",
        stroke: "currentColor",
        viewBox: "0 0 24 24"
    }, React.createElement('path', {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        strokeWidth: 2,
        d: "M14.828 14.828a4 4 0 01-5.656 0M9 10h1m4 0h1m-6 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
    })),
    
    Pause: () => React.createElement('svg', {
        className: "w-6 h-6",
        fill: "none",
        stroke: "currentColor",
        viewBox: "0 0 24 24"
    }, React.createElement('path', {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        strokeWidth: 2,
        d: "M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"
    })),
    
    RotateCcw: () => React.createElement('svg', {
        className: "w-4 h-4",
        fill: "none",
        stroke: "currentColor",
        viewBox: "0 0 24 24"
    }, React.createElement('path', {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        strokeWidth: 2,
        d: "M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6"
    })),
    
    Trophy: () => React.createElement('svg', {
        className: "w-5 h-5",
        fill: "none",
        stroke: "currentColor",
        viewBox: "0 0 24 24"
    }, React.createElement('path', {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        strokeWidth: 2,
        d: "M12 15v5l-3-1 3-1 3 1-3 1zm0 0l-.5-3H12l-.5 3z"
    })),
    
    Zap: () => React.createElement('svg', {
        className: "w-5 h-5",
        fill: "none",
        stroke: "currentColor",
        viewBox: "0 0 24 24"
    }, React.createElement('path', {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        strokeWidth: 2,
        d: "M13 10V3L4 14h7v7l9-11h-7z"
    })),
    
    Volume2: () => React.createElement('svg', {
        className: "w-4 h-4",
        fill: "none",
        stroke: "currentColor",
        viewBox: "0 0 24 24"
    }, React.createElement('path', {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        strokeWidth: 2,
        d: "M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M9 5H7a2 2 0 00-2 2v6a2 2 0 002 2h2l5 5V0L9 5z"
    })),
    
    VolumeX: () => React.createElement('svg', {
        className: "w-4 h-4",
        fill: "none",
        stroke: "currentColor",
        viewBox: "0 0 24 24"
    }, React.createElement('path', {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        strokeWidth: 2,
        d: "M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z M17 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2"
    }))
};

// COMPONENTE: HEADER DEL JUEGO
const GameHeader = () => {
    return React.createElement('div', {
        className: "text-center mb-6"
    }, [
        React.createElement('h1', {
            key: 'title',
            className: "text-3xl md:text-4xl font-bold mb-2"
        }, 'üß© Tetris Balance'),
        React.createElement('p', {
            key: 'subtitle',
            className: "text-lg opacity-90"
        }, '¬°Clasifica los elementos contables mientras caen!')
    ]);
};

// COMPONENTE: PANEL DE CONTROL
const ControlPanel = ({ gameState, onStartGame, onTogglePause, onResetGame, onToggleMusic, onToggleSoundEffects }) => {
    return React.createElement('div', {
        className: "glass-panel p-4 mb-6"
    }, React.createElement('div', {
        className: "flex justify-between items-center flex-wrap gap-4"
    }, [
        // Estad√≠sticas
        React.createElement('div', {
            key: 'stats',
            className: "flex items-center space-x-6 flex-wrap"
        }, [
            React.createElement('div', {
                key: 'score',
                className: "flex items-center space-x-2"
            }, [
                React.createElement(Icons.Trophy, { key: 'trophy-icon' }),
                React.createElement('span', {
                    key: 'score-text',
                    className: "font-bold text-lg"
                }, gameState.stats.score)
            ]),
            
            React.createElement('div', {
                key: 'level',
                className: "flex items-center space-x-2"
            }, React.createElement('span', {
                className: "text-blue-300"
            }, `Nivel ${gameState.stats.level}`)),
            
            React.createElement('div', {
                key: 'lives',
                className: "flex items-center space-x-2"
            }, React.createElement('span', {
                className: "text-red-300"
            }, `‚ù§Ô∏è √ó ${gameState.stats.lives}`)),
            
            gameState.stats.streak > 0 && React.createElement('div', {
                key: 'streak',
                className: "flex items-center space-x-2"
            }, [
                React.createElement(Icons.Zap, { key: 'zap-icon' }),
                React.createElement('span', {
                    key: 'streak-text',
                    className: `text-yellow-300 font-bold ${gameState.stats.streak >= 5 ? 'streak-effect' : 'pulse'}`
                }, `Racha: ${gameState.stats.streak}`)
            ]),
            
            gameState.stats.bestStreak > 0 && React.createElement('div', {
                key: 'best-streak',
                className: "flex items-center space-x-2"
            }, React.createElement('span', {
                className: "text-purple-300 text-sm"
            }, `Mejor: ${gameState.stats.bestStreak}`))
        ]),
        
        // Botones de control
        React.createElement('div', {
            key: 'controls',
            className: "flex space-x-2"
        }, [
            // Bot√≥n principal (Jugar/Pausar)
            !gameState.gameState.isPlaying ? 
                React.createElement('button', {
                    key: 'play-btn',
                    onClick: onStartGame,
                    className: "flex items-center space-x-2 px-4 py-2 btn-primary rounded-lg font-bold"
                }, [
                    React.createElement(Icons.Play, { key: 'play-icon' }),
                    React.createElement('span', { key: 'play-text' }, 'JUGAR')
                ]) :
                React.createElement('button', {
                    key: 'pause-btn',
                    onClick: onTogglePause,
                    className: "flex items-center space-x-2 px-4 py-2 btn-secondary rounded-lg font-bold"
                }, [
                    React.createElement(Icons.Pause, { key: 'pause-icon' }),
                    React.createElement('span', { key: 'pause-text' }, gameState.gameState.isPaused ? 'REANUDAR' : 'PAUSA')
                ]),
            
            // Bot√≥n de reset
            React.createElement('button', {
                key: 'reset-btn',
                onClick: onResetGame,
                className: "flex items-center space-x-2 px-4 py-2 bg-gray-500 rounded-lg hover:bg-gray-600 transition-colors"
            }, [
                React.createElement(Icons.RotateCcw, { key: 'reset-icon' }),
                React.createElement('span', { key: 'reset-text' }, 'RESET')
            ]),
            
            // Controles de audio
            React.createElement('button', {
                key: 'music-btn',
                onClick: onToggleMusic,
                className: `p-2 rounded-lg transition-colors ${
                    gameState.audioState.musicEnabled 
                        ? 'bg-green-500 text-white' 
                        : 'bg-gray-500 text-gray-300'
                }`,
                title: gameState.audioState.musicEnabled ? 'Desactivar m√∫sica' : 'Activar m√∫sica'
            }, gameState.audioState.musicEnabled ? 
                React.createElement(Icons.Volume2, null) : 
                React.createElement(Icons.VolumeX, null)
            ),
            
            React.createElement('button', {
                key: 'sound-btn',
                onClick: onToggleSoundEffects,
                className: `p-2 rounded-lg transition-colors ${
                    gameState.audioState.soundEffectsEnabled 
                        ? 'bg-blue-500 text-white' 
                        : 'bg-gray-500 text-gray-300'
                }`,
                title: gameState.audioState.soundEffectsEnabled ? 'Desactivar efectos' : 'Activar efectos'
            }, gameState.audioState.soundEffectsEnabled ? 
                React.createElement('span', null, 'üîä') : 
                React.createElement('span', null, 'üîá')
            )
        ])
    ]));
};

// COMPONENTE: √ÅREA DE CA√çDA
const GameArea = ({ gameState, gameAreaRef, onMouseDown }) => {
    if (!gameState.gameState.isPlaying || !gameState.gameState.currentElement || !gameState.gameState.isElementFalling) {
        return null;
    }
    
    const element = gameState.gameState.currentElement;
    
    return React.createElement('div', {
        className: "game-board p-6 mb-6"
    }, [
        React.createElement('div', {
            key: 'drop-zone',
            ref: gameAreaRef,
            className: "drop-zone mb-4",
            style: { minHeight: '280px', position: 'relative' }
        }, [
            // Barra de progreso
            React.createElement('div', {
                key: 'progress-bar',
                className: "absolute top-0 left-0 w-full progress-bar"
            }, React.createElement('div', {
                className: "progress-fill",
                style: { width: `${gameState.fallProgress}%` }
            })),
            
            // Elemento cayendo
            React.createElement('div', {
                key: 'falling-element',
                className: `absolute ${element.color} text-white px-6 py-4 rounded-lg shadow-lg glow falling-element ${gameState.gameState.isDragging ? 'scale-105' : ''}`,
                style: {
                    left: `${gameState.config.elementPosition}%`,
                    top: `${30 + (gameState.fallProgress * 0.6)}%`,
                    transform: 'translateX(-50%)',
                    zIndex: 10
                },
                onMouseDown: onMouseDown,
                onTouchStart: onMouseDown
            }, React.createElement('div', {
                className: "text-center"
            }, [
                React.createElement('div', {
                    key: 'icon',
                    className: "text-4xl mb-2"
                }, element.icon),
                React.createElement('div', {
                    key: 'name',
                    className: "text-sm font-bold whitespace-nowrap"
                }, element.name)
            ])),
            
            // Indicador de tiempo
            React.createElement('div', {
                key: 'time-indicator',
                className: "absolute bottom-4 left-0 right-0 text-center"
            }, React.createElement('div', {
                className: "text-white text-opacity-70 text-sm"
            }, `‚è±Ô∏è ${gameState.timeRemaining}s restantes`))
        ]),
        
        // Controles visuales
        React.createElement('div', {
            key: 'controls-info',
            className: "text-center text-white text-opacity-70 text-sm"
        }, React.createElement('div', {
            className: "flex justify-center space-x-4 flex-wrap"
        }, [
            React.createElement('span', { key: 'left' }, '‚Üê A: Izquierda'),
            React.createElement('span', { key: 'right' }, 'D ‚Üí: Derecha'),
            React.createElement('span', { key: 'drag' }, 'üñ±Ô∏è Arrastra'),
            React.createElement('span', { key: 'classify' }, '1-5: Clasificar'),
            React.createElement('span', { key: 'pause' }, 'Espacio: Pausa')
        ]))
    ]);
};

// COMPONENTE: MENSAJE DE PAUSA
const PauseMessage = ({ isPaused }) => {
    if (!isPaused) return null;
    
    return React.createElement('div', {
        className: "text-center mb-6"
    }, React.createElement('div', {
        className: "glass-panel p-6"
    }, [
        React.createElement('h2', {
            key: 'title',
            className: "text-2xl font-bold mb-2"
        }, '‚è∏Ô∏è JUEGO PAUSADO'),
        React.createElement('p', {
            key: 'subtitle',
            className: "text-lg opacity-80"
        }, 'Presiona ESPACIO o el bot√≥n REANUDAR para continuar')
    ]));
};

// COMPONENTE: FEEDBACK
const FeedbackPanel = ({ gameState }) => {
    if (!gameState.ui.showFeedback) return null;
    
    const isCorrect = gameState.ui.feedback.includes('Correcto') || gameState.ui.feedback.includes('¬°Correcto!');
    const element = gameState.gameState.currentElement;
    
    return React.createElement('div', {
        className: `text-center p-4 rounded-lg mb-6 backdrop-blur-sm ${
            isCorrect ? 'feedback-correct' : 'feedback-incorrect'
        }`
    }, [
        React.createElement('p', {
            key: 'feedback-text',
            className: "font-bold text-lg"
        }, gameState.ui.feedback),
        
        element && React.createElement('div', {
            key: 'element-info',
            className: "mt-2 text-sm opacity-90"
        }, [
            React.createElement('span', {
                key: 'icon',
                className: "text-2xl mr-2"
            }, element.icon),
            React.createElement('span', {
                key: 'mapping'
            }, `${element.name} ‚Üí ${CATEGORIES[element.category].name}`)
        ]),
        
        element && element.tip && React.createElement('div', {
            key: 'tip',
            className: "mt-3 p-3 bg-white bg-opacity-20 rounded-lg text-sm"
        }, [
            React.createElement('div', {
                key: 'tip-header',
                className: "font-bold mb-1"
            }, 'üí° Tip:'),
            React.createElement('div', {
                key: 'tip-text'
            }, element.tip)
        ])
    ]);
};

// COMPONENTE: CATEGOR√çAS
const CategoriesGrid = ({ gameState, onCategoryDrop }) => {
    if (gameState.gameState.gameOver) return null;
    
    return React.createElement('div', {
        className: "grid grid-cols-1 md:grid-cols-5 gap-4 mb-6"
    }, Object.entries(CATEGORIES).map(([key, category], index) => {
        const stats = gameState.ui.categoryStats[key];
        const isActive = gameState.ui.activeSlot === key;
        const isEnabled = gameState.gameState.isElementFalling && !gameState.ui.showFeedback && !gameState.gameState.isPaused;
        
        return React.createElement('button', {
            key: key,
            onClick: () => onCategoryDrop(key),
            disabled: !isEnabled,
            className: `category-slot ${category.color} ${category.textColor} border-4 rounded-lg p-4 text-center cursor-pointer transition-all duration-300 flex flex-col justify-center ${
                isActive ? 'active' : ''
            } ${
                isEnabled ? 'hover:scale-105 hover:shadow-lg' : 'opacity-60'
            }`
        }, [
            // N√∫mero de categor√≠a
            React.createElement('div', {
                key: 'number',
                className: "font-bold text-2xl mb-2 bg-white bg-opacity-20 rounded-full w-8 h-8 flex items-center justify-center mx-auto"
            }, index + 1),
            
            // Nombre de categor√≠a
            React.createElement('h3', {
                key: 'name',
                className: "font-bold text-sm mb-2"
            }, category.name),
            
            // Estad√≠sticas
            stats && React.createElement('div', {
                key: 'stats',
                className: "text-xs opacity-75 mt-2"
            }, [
                React.createElement('div', { key: 'correct' }, `‚úì ${stats.correct}`),
                React.createElement('div', { key: 'total' }, `Total: ${stats.attempts}`),
                React.createElement('div', { key: 'percentage' }, 
                    `${stats.attempts > 0 ? Math.round((stats.correct / stats.attempts) * 100) : 0}%`
                )
            ]),
            
            // Indicador de tecla
            React.createElement('div', {
                key: 'key-indicator',
                className: "text-xs opacity-50 mt-1"
            }, `Tecla: ${index + 1}`)
        ]);
    }));
};

// COMPONENTE: ESTAD√çSTICAS EN TIEMPO REAL
const LiveStats = ({ gameState }) => {
    if (!gameState.gameState.isPlaying || gameState.gameState.gameOver) return null;
    
    return React.createElement('div', {
        className: "glass-panel p-4 mb-6"
    }, React.createElement('div', {
        className: "stats-grid"
    }, [
        React.createElement('div', {
            key: 'score',
            className: "stat-item"
        }, [
            React.createElement('div', {
                key: 'value',
                className: "text-2xl font-bold text-green-400"
            }, gameState.stats.score),
            React.createElement('div', {
                key: 'label',
                className: "text-xs text-gray-300"
            }, 'Puntos')
        ]),
        
        React.createElement('div', {
            key: 'level',
            className: "stat-item"
        }, [
            React.createElement('div', {
                key: 'value',
                className: "text-2xl font-bold text-blue-400"
            }, gameState.stats.level),
            React.createElement('div', {
                key: 'label',
                className: "text-xs text-gray-300"
            }, 'Nivel')
        ]),
        
        React.createElement('div', {
            key: 'streak',
            className: "stat-item"
        }, [
            React.createElement('div', {
                key: 'value',
                className: "text-2xl font-bold text-yellow-400"
            }, gameState.stats.streak),
            React.createElement('div', {
                key: 'label',
                className: "text-xs text-gray-300"
            }, 'Racha Actual')
        ]),
        
        React.createElement('div', {
            key: 'speed',
            className: "stat-item"
        }, [
            React.createElement('div', {
                key: 'value',
                className: "text-2xl font-bold text-purple-400"
            }, `${Math.round(gameState.config.fallSpeed / 1000)}s`),
            React.createElement('div', {
                key: 'label',
                className: "text-xs text-gray-300"
            }, 'Velocidad')
        ])
    ]));
};

// COMPONENTE: GAME OVER
const GameOverScreen = ({ gameState, onStartGame }) => {
    if (!gameState.gameState.gameOver) return null;
    
    const grade = gameState.finalGrade;
    
    return React.createElement('div', {
        className: "glass-panel p-8 text-center mb-6"
    }, [
        React.createElement('div', {
            key: 'emoji',
            className: "text-6xl mb-4"
        }, grade.emoji),
        
        React.createElement('h2', {
            key: 'title',
            className: "text-3xl font-bold mb-4"
        }, 'üéÆ GAME OVER'),
        
        React.createElement('div', {
            key: 'grade',
            className: `text-4xl font-bold mb-4 ${grade.color}`
        }, `Calificaci√≥n: ${grade.grade}`),
        
        React.createElement('p', {
            key: 'message',
            className: "text-xl mb-6"
        }, grade.message),
        
        // Estad√≠sticas finales
        React.createElement('div', {
            key: 'final-stats',
            className: "bg-white bg-opacity-10 rounded-lg p-6 mb-6"
        }, React.createElement('div', {
            className: "grid grid-cols-2 md:grid-cols-4 gap-4"
        }, [
            React.createElement('div', {
                key: 'final-score'
            }, [
                React.createElement('div', {
                    key: 'value',
                    className: "text-2xl font-bold text-green-400"
                }, gameState.stats.score),
                React.createElement('div', {
                    key: 'label',
                    className: "text-sm"
                }, 'Puntuaci√≥n Final')
            ]),
            
            React.createElement('div', {
                key: 'final-level'
            }, [
                React.createElement('div', {
                    key: 'value',
                    className: "text-2xl font-bold text-blue-400"
                }, gameState.stats.level),
                React.createElement('div', {
                    key: 'label',
                    className: "text-sm"
                }, 'Nivel Alcanzado')
            ]),
            
            React.createElement('div', {
                key: 'best-streak'
            }, [
                React.createElement('div', {
                    key: 'value',
                    className: "text-2xl font-bold text-purple-400"
                }, gameState.stats.bestStreak),
                React.createElement('div', {
                    key: 'label',
                    className: "text-sm"
                }, 'Mejor Racha')
            ]),
            
            React.createElement('div', {
                key: 'accuracy'
            }, [
                React.createElement('div', {
                    key: 'value',
                    className: "text-2xl font-bold text-yellow-400"
                }, `${gameState.stats.totalAttempts > 0 ? Math.round((gameState.stats.correctAnswers / gameState.stats.totalAttempts) * 100) : 0}%`),
                React.createElement('div', {
                    key: 'label',
                    className: "text-sm"
                }, 'Precisi√≥n')
            ])
        ])),
        
        React.createElement('button', {
            key: 'play-again',
            onClick: onStartGame,
            className: "px-8 py-4 btn-primary rounded-lg text-xl font-bold"
        }, 'üöÄ JUGAR DE NUEVO')
    ]);
};

// COMPONENTE: INSTRUCCIONES
const Instructions = ({ gameState }) => {
    if (gameState.gameState.isPlaying || gameState.gameState.gameOver) return null;
    
    return React.createElement('div', {
        className: "glass-panel p-6 mb-6"
    }, [
        React.createElement('h3', {
            key: 'title',
            className: "text-xl font-bold mb-4 text-center"
        }, 'üìö C√ìMO JUGAR'),
        
        React.createElement('div', {
            key: 'content',
            className: "grid md:grid-cols-2 gap-6"
        }, [
            React.createElement('div', {
                key: 'objective'
            }, [
                React.createElement('h4', {
                    key: 'title',
                    className: "font-bold mb-2 text-green-300"
                }, 'üéØ Objetivo:'),
                React.createElement('ul', {
                    key: 'list',
                    className: "text-sm space-y-1 list-disc list-inside"
                }, [
                    React.createElement('li', { key: '1' }, 'Los elementos contables caen desde arriba'),
                    React.createElement('li', { key: '2' }, 'Mu√©velos con teclado o rat√≥n'),
                    React.createElement('li', { key: '3' }, 'Clasif√≠calos en la categor√≠a correcta'),
                    React.createElement('li', { key: '4' }, '¬°Consigue la mayor puntuaci√≥n posible!')
                ])
            ]),
            
            React.createElement('div', {
                key: 'mechanics'
            }, [
                React.createElement('h4', {
                    key: 'title',
                    className: "font-bold mb-2 text-blue-300"
                }, '‚ö° Mec√°nicas:'),
                React.createElement('ul', {
                    key: 'list',
                    className: "text-sm space-y-1 list-disc list-inside"
                }, [
                    React.createElement('li', { key: '1' }, 'Tienes 3 vidas al comenzar'),
                    React.createElement('li', { key: '2' }, 'Cada nivel aumenta la velocidad'),
                    React.createElement('li', { key: '3' }, 'Las rachas te dan puntos bonus'),
                    React.createElement('li', { key: '4' }, '¬°La m√∫sica cl√°sica del Tetris te acompa√±a!')
                ])
            ])
        ]),
        
        React.createElement('div', {
            key: 'scoring',
            className: "mt-4 p-4 bg-white bg-opacity-10 rounded-lg"
        }, [
            React.createElement('h4', {
                key: 'title',
                className: "font-bold mb-2 text-yellow-300"
            }, 'üèÜ Sistema de Puntuaci√≥n:'),
            React.createElement('div', {
                key: 'rules',
                className: "text-sm grid md:grid-cols-3 gap-2"
            }, [
                React.createElement('div', { key: '1' }, '‚Ä¢ Respuesta correcta: 10 √ó Nivel'),
                React.createElement('div', { key: '2' }, '‚Ä¢ Racha de 5+: Bonus extra'),
                React.createElement('div', { key: '3' }, '‚Ä¢ Cada 150 puntos = Nuevo nivel')
            ])
        ])
    ]);
};

// COMPONENTE: CONTROLES DETALLADOS
const ControlsGuide = () => {
    return React.createElement('div', {
        className: "glass-panel p-4 mb-6"
    }, [
        React.createElement('h3', {
            key: 'title',
            className: "font-bold mb-3 text-center"
        }, 'üéÆ CONTROLES'),
        
        React.createElement('div', {
            key: 'controls',
            className: "grid grid-cols-2 md:grid-cols-6 gap-2 text-sm"
        }, [
            React.createElement('div', {
                key: 'left',
                className: "text-center p-2 bg-white bg-opacity-10 rounded"
            }, [
                React.createElement('div', {
                    key: 'key',
                    className: "font-bold"
                }, '‚Üê A'),
                React.createElement('div', {
                    key: 'action',
                    className: "text-xs opacity-75"
                }, 'Mover Izq.')
            ]),
            
            React.createElement('div', {
                key: 'right',
                className: "text-center p-2 bg-white bg-opacity-10 rounded"
            }, [
                React.createElement('div', {
                    key: 'key',
                    className: "font-bold"
                }, 'D ‚Üí'),
                React.createElement('div', {
                    key: 'action',
                    className: "text-xs opacity-75"
                }, 'Mover Der.')
            ]),
            
            React.createElement('div', {
                key: 'drag',
                className: "text-center p-2 bg-white bg-opacity-10 rounded"
            }, [
                React.createElement('div', {
                    key: 'key',
                    className: "font-bold"
                }, 'üñ±Ô∏è'),
                React.createElement('div', {
                    key: 'action',
                    className: "text-xs opacity-75"
                }, 'Arrastrar')
            ]),
            
            React.createElement('div', {
                key: 'classify',
                className: "text-center p-2 bg-white bg-opacity-10 rounded"
            }, [
                React.createElement('div', {
                    key: 'key',
                    className: "font-bold"
                }, '1-5'),
                React.createElement('div', {
                    key: 'action',
                    className: "text-xs opacity-75"
                }, 'Clasificar')
            ]),
            
            React.createElement('div', {
                key: 'pause',
                className: "text-center p-2 bg-white bg-opacity-10 rounded"
            }, [
                React.createElement('div', {
                    key: 'key',
                    className: "font-bold"
                }, 'ESPACIO'),
                React.createElement('div', {
                    key: 'action',
                    className: "text-xs opacity-75"
                }, 'Pausa')
            ]),
            
            React.createElement('div', {
                key: 'audio',
                className: "text-center p-2 bg-white bg-opacity-10 rounded"
            }, [
                React.createElement('div', {
                    key: 'key',
                    className: "font-bold"
                }, 'M / S'),
                React.createElement('div', {
                    key: 'action',
                    className: "text-xs opacity-75"
                }, 'Audio')
            ])
        ])
    ]);
};

// COMPONENTE: REFERENCIA DE CATEGOR√çAS
const CategoriesReference = ({ gameState }) => {
    if (gameState.gameState.isPlaying || gameState.gameState.gameOver) return null;
    
    return React.createElement('div', {
        className: "glass-panel p-6 mb-6"
    }, [
        React.createElement('h3', {
            key: 'title',
            className: "text-xl font-bold mb-4 text-center"
        }, 'üìä CATEGOR√çAS DEL BALANCE'),
        
        React.createElement('div', {
            key: 'categories',
            className: "grid md:grid-cols-5 gap-4 text-xs"
        }, Object.entries(CATEGORIES).map(([key, category], index) => 
            React.createElement('div', {
                key: key,
                className: `${category.color} ${category.textColor} p-3 rounded-lg`
            }, [
                React.createElement('div', {
                    key: 'name',
                    className: "font-bold mb-1"
                }, `${index + 1}. ${category.name}`),
                React.createElement('div', {
                    key: 'description',
                    className: "text-xs opacity-75"
                }, category.description),
                React.createElement('div', {
                    key: 'examples',
                    className: "text-xs opacity-60 mt-1 font-mono"
                }, category.examples)
            ])
        ))
    ]);
};

// COMPONENTE: FOOTER
const Footer = () => {
    return React.createElement('div', {
        className: "text-center text-white text-opacity-60 text-sm mt-8"
    }, [
        React.createElement('p', {
            key: 'main',
            className: "mb-2"
        }, [
            React.createElement('span', { key: 'icon' }, 'üéì '),
            React.createElement('strong', { key: 'title' }, 'Tetris Balance'),
            React.createElement('span', { key: 'desc' }, ' - Herramienta educativa para Bachillerato')
        ]),
        React.createElement('p', {
            key: 'features'
        }, 'üéµ Con la m√∫sica cl√°sica del Tetris ‚Ä¢ üì± Compatible m√≥vil y PC ‚Ä¢ üÜì Totalmente gratuito')
    ]);
};

// COMPONENTE PRINCIPAL DE LA APLICACI√ìN
const TetrisBalanceApp = () => {
    // Estados de React
    const [gameState, setGameState] = useState(null);
    const [updateTrigger, setUpdateTrigger] = useState(0);
    
    // Referencias
    const gameAreaRef = useRef(null);
    const gameInstanceRef = useRef(null);
    const updateIntervalRef = useRef(null);
    
    // Inicializar juego
    useEffect(() => {
        console.log('üöÄ Inicializando aplicaci√≥n React...');
        
        // Obtener o crear instancia del juego
        gameInstanceRef.current = getGameInstance();
        
        // Configurar referencia del √°rea de juego
        gameInstanceRef.current.refs.gameAreaRef = gameAreaRef.current;
        
        // Configurar actualizaci√≥n peri√≥dica del estado
        updateIntervalRef.current = setInterval(() => {
            if (gameInstanceRef.current) {
                const currentState = gameInstanceRef.current.getGameState();
                setGameState(currentState);
            }
        }, 100); // Actualizar cada 100ms
        
        // Actualizaci√≥n inicial
        const initialState = gameInstanceRef.current.getGameState();
        setGameState(initialState);
        
        return () => {
            if (updateIntervalRef.current) {
                clearInterval(updateIntervalRef.current);
            }
        };
    }, []);
    
    // Actualizar referencia del √°rea de juego cuando cambie
    useEffect(() => {
        if (gameInstanceRef.current && gameAreaRef.current) {
            gameInstanceRef.current.refs.gameAreaRef = gameAreaRef.current;
        }
    }, [gameAreaRef.current]);
    
    // Funciones de control del juego
    const handleStartGame = useCallback(() => {
        if (gameInstanceRef.current) {
            gameInstanceRef.current.startGame();
            setUpdateTrigger(prev => prev + 1);
        }
    }, []);
    
    const handleTogglePause = useCallback(() => {
        if (gameInstanceRef.current) {
            gameInstanceRef.current.togglePause();
            setUpdateTrigger(prev => prev + 1);
        }
    }, []);
    
    const handleResetGame = useCallback(() => {
        if (gameInstanceRef.current) {
            gameInstanceRef.current.resetGame();
            setUpdateTrigger(prev => prev + 1);
        }
    }, []);
    
    const handleToggleMusic = useCallback(() => {
        if (gameInstanceRef.current) {
            gameInstanceRef.current.toggleMusic();
            setUpdateTrigger(prev => prev + 1);
        }
    }, []);
    
    const handleToggleSoundEffects = useCallback(() => {
        if (gameInstanceRef.current) {
            gameInstanceRef.current.toggleSoundEffects();
            setUpdateTrigger(prev => prev + 1);
        }
    }, []);
    
    const handleCategoryDrop = useCallback((category) => {
        if (gameInstanceRef.current) {
            gameInstanceRef.current.handleCategoryDrop(category);
            setUpdateTrigger(prev => prev + 1);
        }
    }, []);
    
    const handleMouseDown = useCallback((e) => {
        if (gameInstanceRef.current) {
            gameInstanceRef.current.handleMouseDown(e);
            setUpdateTrigger(prev => prev + 1);
        }
    }, []);
    
    // Mostrar loading si no hay estado
    if (!gameState) {
        return React.createElement('div', {
            className: "min-h-screen game-container flex items-center justify-center text-white"
        }, React.createElement('div', {
            className: "text-center"
        }, [
            React.createElement('div', {
                key: 'loading-icon',
                className: "text-6xl mb-4"
            }, 'üß©'),
            React.createElement('div', {
                key: 'loading-text',
                className: "text-xl"
            }, 'Cargando Tetris Balance...')
        ]));
    }
    
    // Render principal
    return React.createElement('div', {
        className: "min-h-screen game-container p-4 text-white"
    }, React.createElement('div', {
        className: "max-w-6xl mx-auto"
    }, [
        // Header
        React.createElement(GameHeader, { key: 'header' }),
        
        // Panel de control
        React.createElement(ControlPanel, {
            key: 'control-panel',
            gameState: gameState,
            onStartGame: handleStartGame,
            onTogglePause: handleTogglePause,
            onResetGame: handleResetGame,
            onToggleMusic: handleToggleMusic,
            onToggleSoundEffects: handleToggleSoundEffects
        }),
        
        // √Årea de juego
        React.createElement(GameArea, {
            key: 'game-area',
            gameState: gameState,
            gameAreaRef: gameAreaRef,
            onMouseDown: handleMouseDown
        }),
        
        // Mensaje de pausa
        React.createElement(PauseMessage, {
            key: 'pause-message',
            isPaused: gameState.gameState.isPaused
        }),
        
        // Feedback
        React.createElement(FeedbackPanel, {
            key: 'feedback',
            gameState: gameState
        }),
        
        // Categor√≠as
        React.createElement(CategoriesGrid, {
            key: 'categories',
            gameState: gameState,
            onCategoryDrop: handleCategoryDrop
        }),
        
        // Estad√≠sticas en vivo
        React.createElement(LiveStats, {
            key: 'live-stats',
            gameState: gameState
        }),
        
        // Game Over
        React.createElement(GameOverScreen, {
            key: 'game-over',
            gameState: gameState,
            onStartGame: handleStartGame
        }),
        
        // Gu√≠a de controles
        React.createElement(ControlsGuide, { key: 'controls-guide' }),
        
        // Instrucciones
        React.createElement(Instructions, {
            key: 'instructions',
            gameState: gameState
        }),
        
        // Referencia de categor√≠as
        React.createElement(CategoriesReference, {
            key: 'categories-ref',
            gameState: gameState
        }),
        
        // Footer
        React.createElement(Footer, { key: 'footer' })
    ]));
};

// RENDERIZAR LA APLICACI√ìN
document.addEventListener('DOMContentLoaded', () => {
    console.log('üéÆ Iniciando Tetris Balance...');
    
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(React.createElement(TetrisBalanceApp));
    
    console.log('‚úÖ Aplicaci√≥n renderizada correctamente');
});

// EXPORTAR (para uso con m√≥dulos)
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        TetrisBalanceApp,
        Icons
    };
}